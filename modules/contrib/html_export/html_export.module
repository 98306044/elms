<?php

define('HTML_EXPORT_PROCESS_LIMIT', 5);
define('HTML_EXPORT_FILE_PROCESS_LIMIT', 2);

// ELMS: HTML Export - Export drupal paths to HTML
// Copyright (C) 2008-2012  The Pennsylvania State University
//
// Bryan Ollendyke
// bto108@psu.edu
//
// Keith D. Bailey
// kdb163@psu.edu
//
// 12 Borland
// University Park, PA 16802

/**
 * Implementation of hook_help().
 */
function html_export_help($section) {
  switch ($section) {
    case 'admin':
      return t("HTML Export lets you export drupal paths to static HTML.");
  }
}

/**
 * Implementation of hook_perms().
 */
function html_export_perms() {
  return array('use html export');
}

/**
 * Implementation of hook_menu().
 */
function html_export_menu() {
  $items = array();
  $items['html_export'] = array(
    'title' => 'HTML export',
    'description' => 'Export paths to HTML files',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('_html_export_job_page'),
    'access arguments' => array('use html export'),
    'file' => 'html_export.pages.inc',
  );
  $items['admin/settings/html_export'] = array(
    'title' => 'HTML export',
    'description' => 'Configure how HTML is exported',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('_html_export_settings'),
    'access arguments' => array('administer site configuration'),
    'file' => 'html_export.admin.inc',
  );
  return $items;
}

/**
 * Implementation of hook_html_export_add_path_provider().
 */
function html_export_html_export_add_path_provider() {
  $items = array(
    'core_all_nodes' => array(
      'title' => 'Core: All nodes',
      'callback' => '_html_export_all_nodes',
    ),
    'core_all_paths' => array(
      'title' => 'Core: all menu paths',
      'callback' => '_html_export_all_menu_links',
    ),
  );
  // create an option for each type
  $avail_types = variable_get('html_export_available_types', array());
  foreach ($avail_types as $key => $type) {
    $items['types_'. $key] = array(
      'title' => 'Node type: '. $key,
      'callback' => '_html_export_node_type',
      'arg' => $key,
    );
  }
  // if views is active then add in those paths
  if (module_exists('views')) {
    $avail_views = variable_get('html_export_available_views', array());
    foreach ($avail_views as $view) {
      $items['views_'. $view] = array(
        'title' => 'Views: '. $view,
        'callback' => '_html_export_handle_view',
        'arg' => $view,
      );
    }
  }
  return $items;
}


/**
 * Callback for core_all_paths provider.
 */
function _html_export_handle_view($view_name) {
  $paths = array();
  $results = views_get_view_result($view_name);
  // list of nodes from a view
  foreach ($results as $row) {
    if (isset($row->nid)) {
      $paths['node/'. $row->nid] = 'node/'. $row->nid;
    }
  }
  return $paths;
}

/**
 * Callback for core_all_paths provider.
 */
function _html_export_all_menu_links() {
  $paths = array();
  $result = db_query("SELECT link_path FROM {menu_links}");
  while ($val = db_fetch_array($result)) {
    // ensure that % isn't taking context into account w/ the path
    if (strpos($val['link_path'], '%') === FALSE) {
      $paths[$val['link_path']] = $val['link_path'];
    }
  }
  return $paths;
}

/**
 * Callback for core_all_nodes provider.
 */
function _html_export_all_nodes() {
  $paths = array();
  // grab all nodes the user has access to
  $result = db_query(db_rewrite_sql("SELECT nid FROM {node} as n"));
  while ($val = db_fetch_array($result)) {
    $paths['node/'. $val['nid']] = 'node/'. $val['nid'];
  }
  return $paths;
}

/**
 * Callback for core_node_type provider.
 */
function _html_export_node_type($type) {
  $paths = array();
  // grab all nodes the user has access to for this type
  $result = db_query(db_rewrite_sql("SELECT nid FROM {node} as n WHERE type='%s'"), $type);
  while ($val = db_fetch_array($result)) {
    $paths['node/'. $val['nid']] = 'node/'. $val['nid'];
  }
  return $paths;
}

/**
 * Implementation of hook_html_export_data_alter().
 */
function html_export_html_export_data_alter(&$data, $paths, $active_path_count, $dom_remove) {
  // advanced dom removal routine
  // Create a DOM object
  $html_obj = new simple_html_dom();
  // Load HTML from a string
  $html_obj->load($data);
  // remove the selectors
  foreach ($dom_remove as $find) {
    // find the selectors in the document
    $objs = $html_obj->find($find);
    // account for ability to find multiple objects
    foreach ($objs as $obj) {
      $obj->outertext = '';
    }
  }
  // remove base_path so that everything is relative to root
  $sub = '';
  // we need to retrace paths to account for nesting
  $tmp = explode('/', $paths[$active_path_count]);
  foreach ($tmp as $dir) {
    $sub .= '../';
  }
  $resources = array('link', 'img', 'script', 'a', 'object');
  // repair paths for these resources
  foreach ($resources as $find) {
    // find the selectors in the document
    $objs = $html_obj->find($find);
    // account for ability to find multiple objects
    foreach ($objs as $obj) {
      // account for internal href resources
      if (isset($obj->href) && strpos($obj->href, 'http://') === FALSE && strpos($obj->href, 'https://') === FALSE) {
        // only replace first occurance as this will be base path
        $pos = strpos($obj->href, base_path());
        if ($pos !== FALSE) {
          $obj->href = substr_replace($obj->href, $sub, $pos, drupal_strlen(base_path()));
        }
      }
      // account for internal src resources
      if (isset($obj->src) && strpos($obj->src, 'http://') === FALSE && strpos($obj->src, 'https://') === FALSE) {
        // only replace first occurance as this will be base path
        $pos = strpos($obj->src, base_path());
        if ($pos !== FALSE) {
          $obj->src = substr_replace($obj->src, $sub, $pos, drupal_strlen(base_path()));
        }
      }
    }
  }
  // write all these changes back into the data string
  $data = $html_obj->save();
  // process all paths we were given to append .html
  foreach ($paths as $path) {
    // rewrite aliases to non-aliases
    $alias = drupal_get_path_alias($path);
    if ($alias != $path) {
      $data = str_replace($alias, $path .'/index.html', $data);
    }
    $data = str_replace($path, $path .'/index.html', $data);
  }
}

/**
 * Helper function to archive a directory if extension exists
 */
function html_export_compress_directory($source, &$context) {
  return FALSE;
  // this isn't working yet but it in the right direction
  if (!extension_loaded('zlib') || !file_exists($source)) {
    return FALSE;
  }
  $destination = $source .'.gz';
  $fp = gzopen($destination, 'w9'); // w9 == highest compression
  $iterator = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($source), RecursiveIteratorIterator::CHILD_FIRST);
  foreach ($iterator as $path) {
    gzwrite($fp, $path);
  }
  gzclose($fp);
  return TRUE;
}
