<?php
// $Id: elms_spaces.module

/**
 * @file
 * Spaces specific helper functions to help organize space specific settings / pages into their own area
 */

/**
 * Implementation of hook_init()
 */
function elms_spaces_init() {
  //only add these settings to the node/%theme page
  if (arg(0) == 'node' && arg(2) == 'theme') {
    drupal_add_js(drupal_get_path('module', 'elms_spaces') .'/elms_spaces.js');
  }
  drupal_add_js(drupal_get_path('module', 'elms_spaces') .'/elms_spaces_reorder.js');
  //style the progress bar page for batch processes since we do a lot of them
  if (arg(0) == 'batch') {
  drupal_add_css(drupal_get_path('module', 'elms_spaces') .'/progress.css');  
  }
}
/**
 * Implementation of hook_menu()
 */
function elms_spaces_menu() {
  $items = array();
  $items['node/%/theme'] = array(
    'title' => 'Theme Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('_elms_spaces_theme_form'),
    'type' => MENU_NORMAL_ITEM,
  'access callback' => '_elms_spaces_theme_access',
    'access arguments' => array(),
    'file' => 'elms_spaces.theme.inc',
    'file path' => drupal_get_path('module','elms_spaces') .'/inc',
  );
  return $items;
}

//determine if someone can access the /theme page based on whether or not they have access to edit the space
//CHANGE access method to that of features as this check is overkill
function _elms_spaces_theme_access() {
  global $user;
  $node = og_get_group_context();
  if (!og_is_group_type($node->type) || !user_access('edit own course content')) {
    return 0;
  }

  return 1;
}

/**
 * Implementation of hook_form_alter()
 * this exists because it fires much later then elms helper and can override some things that helper cannot based on its weight
 */
function elms_spaces_form_alter(&$form, &$form_state, $form_id) {
  //alter the version form
  if ($form_id == 'version_node_form') {
    //always hide purl, they shouldn't need to know anything about it, it just happens
    $form['purl']['value']['#type'] = 'hidden';
    //remove duplicate effort buttons
    unset($form['buttons']['all']);
    //because purl wants a url, generate a temporary, random one
    //this has to be done because the nid hasn't been set yet and we can't submit the node until we have a PURL identifier yet the NID is supposed to be part of the address
    if (arg(1) == 'add') {
      $form['purl']['value']['#default_value'] = '_dev_'. rand(1,1000);
    }
    else {
      //account for content outline, we only want to be able to set it once
	  //CHANGE featurization this will no longer be needed
      if (arg(3) == 2 && _multistep_get_status(arg(1),2) == 'submitted') {
        unset($form['field_instructional_template']);
      }
      //goofy setting the first time through to make sure chamfer is the default selected even though chamfer isn't the default theme used system wide
	  //CHANGE allow for a global setting to select which theme is the default
      if (arg(3) == 4 && _multistep_get_status(arg(1),4) == 'unsubmitted') {
        $form['themes']['theme']['#default_value'] = 'chamfer';
      }
    }
  }
}

/**
 * Implementation of hook_nodeapi().
 */
function elms_spaces_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  switch ($op) {
    case 'load':
    //for group nodes, load in the ID of the book outline
    if (og_is_group_type($node->type)) {
      if (arg(2) == 'edit') {
        //kill annoying status messages for editing course nodes
        $_SESSION['messages'] = array();
      }
	  //there's only 1 book per group so load the id and store it in the node object
	  //also store the outline mlid to avoid duplicate querying in the future
      $result = db_query("SELECT mlid,{book}.nid FROM {og_ancestry} JOIN {book} ON {book}.nid = {og_ancestry}.nid WHERE {book}.nid = {book}.bid AND group_nid=%d", $node->nid);
      $val = db_fetch_array($result);
      $node->book_outline_mlid = $val['mlid'];
      $node->book_nid = $val['nid'];
      //only unset this on the schedule step of the group
	  //CHANGE featurization this is no longer needed
      if (arg(2) == 'edit' && arg(3) == 3) {
        $node->field_schedule_to_build[0]['value'] = '';  
      }
    }
  break;
  case 'insert':
    //when a course is inserted we automatically create a version for it
    if ($node->type == 'course') {
      _elms_spaces_course_default($node);
    }
    //need this to run ONLY after the group node has been created and cause of multistep there isnt much work to do here
    if (og_is_group_type($node->type)) {
      $space = spaces_load('og', $node->nid, TRUE);
      if ($space) {
        $space->controllers->variable->set('site_name', $node->title);
        //load the course node for the name space info
		$course = node_load($node->field_course_ref[0]['nid']);
        //set slogan to the description of the course
        $space->controllers->variable->set('site_slogan', $course->field_course_title[0]['value']);
        //need to do extra step with purl rewrite to ensure it has the node and course name in in
        $modifier = array(
          'value' => $course->path .'_dev_'. $node->nid,
          'provider' => 'spaces_og',
          'id' => $node->nid,
        );
        purl_save($modifier);
      }
    }
    break;
    case 'update':
      //only add this in for group / course nodes
      if (og_is_group_type($node->type)) {
        //need to run through the steps one at a time
        $step = arg(3);
        //see if this is the /theme page and ignore additional processing if it is
        if (arg(2) == 'theme' || arg(2) == 'workflow') {
          $step = 0;
        }
      switch ($step) {
        //this only happens AFTER initial submission of the node (creating it)
        //also need the blank case cause it could be a null step meaning step 1
        case '':
        case 1:
          _multistep_update_status($node->nid,'submitted',1);
          $space = spaces_load('og', $node->nid, TRUE);
          if ($space) {
            $space->controllers->variable->set('site_name', $node->title);
            //set the front page to the homepage of the course
            $space->controllers->variable->set('site_frontpage', 'node/'. $node->nid);
            $course = node_load($group->field_course_ref[0]['nid']);
            //set slogan to the description of the course
            $space->controllers->variable->set('site_slogan', $course->field_course_description[0]['value']);
          }
        break;
        //create the course outline, always removing the current one if its a rebuild
        case 2:
          _multistep_update_status($node->nid,'submitted',2);
          $space = spaces_load('og', $node->nid, TRUE);
          $root = db_result(db_query("SELECT {book}.nid FROM {og_ancestry} JOIN {book} ON {book}.nid = {og_ancestry}.nid WHERE group_nid=%d", $node->nid));
          //if no root was returned then create one as well as the instructional template selected if there is one
          if (!$root) {
            _elms_spaces_create_root($node, $node->field_instructional_template[0]['value']);
          }
        break;
        //create the schedule, always removing the current one if its a rebuild
        case 3:
          _multistep_update_status($node->nid,'submitted',3);
          //remove the current schedule and build a new one
          if (module_exists('elms_schedule') && ($node->field_schedule_to_build[0]['value'] != '')) {
            if ($node->field_schedule_to_build[0]['value'] == 'rebuild') {
              $batch_call = '_elms_schedule_rebuild_schedule';
              $batch_title = 'Mapping Schedule';
            }
          else {
            //select all course events attached to this group
            $result = db_query("SELECT {node}.nid FROM {og_ancestry} JOIN {node} ON {node}.nid = {og_ancestry}.nid WHERE group_nid=%d AND {node}.type='course_event'", $node->nid);
            while ($val = db_fetch_array($result)) {
              node_delete($val['nid']);
            }
            $batch_call = '_elms_schedule_build_schedule';
            $batch_title = 'Building Schedule';
          }
          $batch = array(
            'title' => t($batch_title),
            'progress_message' => t('Completed job @current of @total.'),
            'operations' => array(
              array($batch_call, array($node)),
              array('_elms_spaces_node_access_rebuild_batch_operation', array($node)),
            ),
            'init_message' => t('Loading schedule'),
            'error_message' => t('An error has occured'),
            'finished' => '_elms_spaces_duplicate_branch_finished',
          );
          batch_set($batch);
          batch_process('node/'. $node->nid .'/edit/4');
        }
      break;
      //node is completed by multistep and sets the theme if there's a change
      case 4:
        _multistep_update_status($node->nid,'submitted',4);
      break;
      case 5:
        _multistep_update_status($node->nid,'submitted',5);
      break;
      case 6:
        _multistep_update_status($node->nid,'submitted',6);
        $space = spaces_load('og', $node->nid, TRUE);
        if ($space) {
          //account for webaccess, making private courses force a webaccess prompt
          if (module_exists('webaccess')) {
            $space->controllers->variable->set('webaccess_secure_site', $node->og_private);
          }  
        }
        $batch = array(
          'title' => t('Verifying Access Permissions'),
          'progress_message' => t('Completed job @current of @total.'),
          'operations' => array(
            array('_elms_spaces_node_access_rebuild_batch_operation', array($node)),
		  ),
          'init_message' => t('Building access permissions'),
          'error_message' => t('An error has occured'),
          'finished' => '_elms_spaces_duplicate_branch_finished',
        );
        batch_set($batch);
        batch_process('node/'. $node->nid);
      break;
      //steps beyond what we've mapped, do nothing
      default:
      break;
    }
  }
  break;
  //clean up all spaces overrides for the node
  //CHANGE need to check that this is a space / group or there's nothing to override
  case 'delete':
    db_query("DELETE FROM {spaces_overrides} WHERE id=%d",$node->nid);
  break;
  }
}

//helper function to duplicate a certain book structure.  this is similar to how the outline designer duplicates content but this will set the new group based on the node in question
function _elms_spaces_duplicate_branch($node, $group, &$context) {
  global $user;
  //intial setting of the batch job
  if (!isset($context['sandbox']['progress'])) {
  //figure out the print settings
  switch ($group->field_print_options[0]['value']) {
    case 'both':
      $context['sandbox']['print_display'] = 1;
      $context['sandbox']['print_pdf_display'] = 1;
    break;
    case 'print':  
      $context['sandbox']['print_display'] = 1;
      $context['sandbox']['print_pdf_display'] = 0;
    break;
    case 'pdf':
      $context['sandbox']['print_display'] = 0;
      $context['sandbox']['print_pdf_display'] = 1;
    break;
    default:
      $context['sandbox']['print_display'] = 0;
      $context['sandbox']['print_pdf_display'] = 0;
    break;
  }
  //get max
  $context['sandbox']['max'] = db_result(db_query("
    SELECT COUNT(mlid)
    FROM {menu_links}  
    WHERE p1=%d
    ORDER BY depth ASC, mlid ASC", $node->book['mlid']));
  //build array for cycling through the batch
  $context['sandbox']['mlid_list'] = array();
  $result = db_query("
    SELECT mlid
    FROM {menu_links}  
    WHERE p1=%d
    ORDER BY depth ASC, mlid ASC", $node->book['mlid']);
  while ($val = db_fetch_array($result)) {
    $context['sandbox']['mlid_list'][] = $val['mlid'];
  }
  $context['sandbox']['mlid'] = array();
  $context['sandbox']['progress'] = 0;
  $context['sandbox']['map'] = array();
  }
  //build 10 at a time
  $mlids[] = $context['sandbox']['mlid_list'][$context['sandbox']['progress']];
  $mlids[] = $context['sandbox']['mlid_list'][$context['sandbox']['progress']+1];
  $mlids[] = $context['sandbox']['mlid_list'][$context['sandbox']['progress']+2];
  $mlids[] = $context['sandbox']['mlid_list'][$context['sandbox']['progress']+3];
  $mlids[] = $context['sandbox']['mlid_list'][$context['sandbox']['progress']+4];
  $mlids[] = $context['sandbox']['mlid_list'][$context['sandbox']['progress']+5];
  $mlids[] = $context['sandbox']['mlid_list'][$context['sandbox']['progress']+6];
  $mlids[] = $context['sandbox']['mlid_list'][$context['sandbox']['progress']+7];
  $mlids[] = $context['sandbox']['mlid_list'][$context['sandbox']['progress']+8];
  $mlids[] = $context['sandbox']['mlid_list'][$context['sandbox']['progress']+9];

  $result = db_query("
    SELECT nid
    FROM {menu_links} 
    JOIN {book} ON {book}.mlid = {menu_links}.mlid 
    WHERE {menu_links}.mlid IN(%d,%d,%d,%d,%d,%d,%d,%d,%d,%d) 
     ORDER BY depth ASC, {menu_links}.mlid ASC", $mlids[0], $mlids[1], $mlids[2], $mlids[3], $mlids[4], $mlids[5], $mlids[6], $mlids[7], $mlids[8], $mlids[9]);
  while ($value = db_fetch_array($result)) {
    $dup_node = node_load($value['nid']);
    $current_nid = $dup_node->nid;
    $old_nid = $dup_node->nid;
    //remove public flag in case the outline duplicated had that flag
    unset($dup_node->og_public);
    unset($dup_node->og_private);
    //kill off all groups from the array
    $dup_node->og_groups = NULL;
    $dup_node->og_groups_both = NULL;
    //add in the newly created group
    $dup_node->og_groups = array($group->nid => $group->nid);
    $dup_node->og_groups_both = array($group->nid => $group->title);
    //remove the factors that would make this the old node
    $dup_node->path = NULL;
    $dup_node->nid = NULL;
    $dup_node->created = NULL;
  //see if we want to wipe the content or bring it along
  if ($group->field_create_outline_mode[0]['value'] == 'duplicate_structure') {
      $dup_node->body = '';
  }
    //take into account uuid usage, needed for node_export_book module to work
    $dup_node->uuid = NULL;
    $dup_node->revision_uuid = NULL;
    //use print setting default based on the group's setting
    $dup_node->print_display = $context['sandbox']['print_display'];
    $dup_node->print_pdf_display = $context['sandbox']['print_pdf_display'];
    //set to current uid
    $dup_node->uid = $user->uid;
    //make sure revision is 1
    $dup_node->revision = 1;
    $old_mlid = $dup_node->book['mlid'];
    $dup_node->book['mlid'] = NULL;
    $dup_node->log = "ELMS replicated this off of the old node nid: $old_nid";
    //if this doesn't have a parent it's the book root so change the title
    if ($dup_node->book['plid'] == 0) {
      $root = TRUE;
      $dup_node->title = $group->title .' - Course Outline';
    }
    else {
      $root = FALSE;
    }
    if (isset($context['sandbox']['map'][$dup_node->book['plid']]) ) {
      $dup_node->book['plid'] = $context['sandbox']['map'][$dup_node->book['plid']];
    }
    //ensure there's no escalation even though it shouldn't be possible
    if (node_access('create', $dup_node)) {
      node_save($dup_node);
    $context['message'] = 'Assembling Course Outline: Creating page '. $dup_node->title .' ('. ($context['sandbox']['max'] - $context['sandbox']['progress']) .' pages remaining)';
      //store this new nid since it's the new book root
      if ($root) {
        $context['sandbox']['root_nid'] = $dup_node->nid;
      }
      $context['sandbox']['map'][$old_mlid] = $dup_node->book['mlid'];
    }
    $context['sandbox']['progress']++;
  }
  //this is the last run, make sure we move the book to it's new branch
  if ($context['sandbox']['progress'] == $context['sandbox']['max']) {
    //everything has been duplicated correctly, now move it to it's own book
    $rootnode = node_load($context['sandbox']['root_nid']);
    $rootnode->book['bid'] = $rootnode->nid;
    $rootnode->book['menu_name'] = book_menu_name($rootnode->book['bid']);
    //update outline for new book
    _book_update_outline($rootnode);
  }

  // Multistep processing : report progress.
  if ($context['sandbox']['progress'] != $context['sandbox']['max']) {
    //need to pass through the map that's been built
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max'];
  }
}

//helper function to create a book for a course version and populate it based on preset chosen
function _elms_spaces_create_root($group, $template = NULL) {
  global $user;
  //creating a blank node
  $node = new StdClass();
  $node->uid = $user->uid;
  $node->type = 'folder';
  $node->status = 1;
  $node->log = 'ELMS outline root created';
  $node->revision = 1;
  $node->book['mlid'] = NULL;
  $node->title = $group->title .' - Course Outline';
  //settings based on group context in ELMS
  //print settings based on those defined by the group
  switch ($group->field_print_options[0]['value']) {
      case 'both':
        $node->print_display = 1;
        $node->print_pdf_display = 1;
      break;
      case 'print':  
      $node->print_display = 1;
        $node->print_pdf_display = 0;
      break;
      case 'pdf':
      $node->print_display = 0;
        $node->print_pdf_display = 1;
      break;
      default:
        $node->print_display = 0;
        $node->print_pdf_display = 0;
      break;
    }
  //set group association
  $node->og_groups = array($group->nid => $group->nid);
  $node->og_groups_both = array($group->nid => $group->title);
  //save the book root
  node_save($node);
  //set book outline association automatically
  $node->book['bid'] = $node->nid;
  $node->book['menu_name'] = book_menu_name($node->book['bid']);
  $node->book['module'] = 'book';
  //update outline for new book
  _book_update_outline($node);
  //see if we were passed an instructional template to use, should be
  if ($template != NULL) {
   $id_template = _elms_course_content_get_instructional_template($template);
  $id_template_tmp = $id_template;
  //loop through each item in the defined template and build it as a new book item
  foreach ($id_template_tmp as $key => $book_item) {
    if ($book_item['type'] == 'duplicate') {
    //now replicate
    $backhalf = array_splice($id_template, $key);
    //now grab just the chunk to clone
    $clone_this = array_splice($id_template, $book_item['parent']);
    $clone_this[0]['origin'] = $book_item['parent'];
    foreach($clone_this as $clone_key => $clone) {
      $clone_this[$clone_key]['clone'] = 1;
    }
    //remove the duplicate request and merge back together
    array_shift($backhalf);
    for($i=0; $i<$group->field_lesson_count[0]['value']; $i++) {
      $id_template = array_merge($id_template, $clone_this);
    }
    $id_template = array_merge($id_template, $backhalf);
    }
  }
  $count = 1;
  foreach ($id_template as $key => $book_item) {
    if (isset($book_item['origin'])) {
      $current_origin = $key;
      $id_template[$key]['title'] = str_replace('@i',$count,$id_template[$key]['title']);
      $count++;
    }
    if (isset($id_template[$key]['parent']) && isset($id_template[$key]['clone'])) {
      $id_template[$key]['parent'] = $current_origin;
    }
  }
  //now we can run the loop that makes it all
  foreach ($id_template as $key => $book_item) {
      $bookpage = new StdClass();
      $bookpage->uid = $user->uid;
    //if we receive a duplication request, utilize the outline designer duplicate function
    //alter the array to have the correct values
    $bookpage->type = $book_item['type'];
    $bookpage->title = $book_item['title'];
    $bookpage->og_groups = array($group->nid => $group->nid);
    $bookpage->og_groups_both = array($group->nid => $group->title);
    $bookpage->status = 1;
    $bookpage->revision = 1;
    $bookpage->log = 'Template '. $template .' used to create outline page automatically';
    //place it in the book correctly
    $bookpage->book['bid'] = $node->nid;
    $bookpage->book['weight'] = $key-15;
    $bookpage->book['module'] = 'book';
    if ($book_item['type'] == 'link') {
      $bookpage->field_link[0]['value'] = $book_item['link'];
    }
    //we've defined a hierarchy in the template for nested nodes
    if (isset($book_item['parent'])) {
      $bookpage->book['plid'] = $book_map[$book_item['parent']];
    }
    node_save($bookpage);
    $book_map[$key] = $bookpage->book['mlid'];
    $nid_map[$key] = $bookpage->nid;
    }
  }
  watchdog('elms', t('New book outline created for the course version'));
}

function _elms_spaces_duplicate_branch_finished($success, $results, $operations) {
  if ($success) {
    $message = t('Welcome to your course');
    watchdog('elms', 'New course has been created');
  }
  else {
    $message = t('Finished with errors, check the error log.');
    watchdog('elms', 'There was an error during course creation');
  }
  drupal_set_message($message,'elms-message');
}

function _elms_spaces_rebuild_finished($success, $results, $operations) {
  if ($success) {
    $message = t('Schedule mapping successful! Make sure you verify dates and events are correct as this takes the start date of both and lines them up without adding or removing events.  This is a best guess and not guaranteed accurate.');
    watchdog('elms', 'Schedule Rebuilt');
  }
  else {
    $message = t('Finished with errors, check the error log.');
    watchdog('elms', 'There was an error during schedule rebuild');
  }
  drupal_set_message($message,'elms-message');
}

/*
 *rewrite of the function that rebuilds all node permissions in the system
 *helps speed things up by rebuilding things associated to the current group
 *need to rebuild all permissions of all nodes in the current group
 */
function _elms_spaces_node_access_rebuild_batch_operation($group, &$context) {
  if (empty($context['sandbox'])) {
    // Initiate multistep processing.
    $context['sandbox']['progress'] = 0;
    $context['sandbox']['current_node'] = 0;
    $context['sandbox']['max'] = db_result(db_query('SELECT COUNT(DISTINCT {node}.nid) FROM {node} JOIN {og_ancestry} ON {og_ancestry}.nid = {node}.nid WHERE group_nid=%d',$group->nid));
  db_query("DELETE FROM {node_access} WHERE nid=%d", $group->nid);
  //need to rebuild the group node's permission so we do that the first run
  $loaded_node = node_load($group->nid, NULL, TRUE);
    // To preserve database integrity, only aquire grants if the node
    // loads successfully.
    if (!empty($loaded_node)) {
      node_access_acquire_grants($loaded_node);
    }
  }

  // Process the next 50 nodes.
  $limit = 50;
  $result = db_query_range("SELECT {node}.nid FROM {node} JOIN {og_ancestry} ON {og_ancestry}.nid = {node}.nid WHERE {node}.nid > %d AND group_nid=%d ORDER BY {node}.nid ASC", $context['sandbox']['current_node'], $group->nid, 0, $limit);
  while ($row = db_fetch_array($result)) {
  //clear current records for the group
  db_query("DELETE FROM {node_access} WHERE nid=%d", $row['nid']);
  //load the node for grant rebuild
    $loaded_node = node_load($row['nid'], NULL, TRUE);
    // To preserve database integrity, only aquire grants if the node
    // loads successfully.
    if (!empty($loaded_node)) {
      node_access_acquire_grants($loaded_node);
    }
    $context['sandbox']['progress']++;
    $context['sandbox']['current_node'] = $row['nid'];
  }
  $context['message'] = 'Rebuilding Content Permissions: '. ($context['sandbox']['max'] - $context['sandbox']['progress']) .' pages remaining';
  // Multistep processing : report progress.
  if ($context['sandbox']['progress'] != $context['sandbox']['max']) {
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max'];
  }
  //last run
  if ($context['sandbox']['progress'] == $context['sandbox']['max']) {
  $context['message'] = t('Content permissions have been rebuilt.');
  og_node_access_needs_rebuild(FALSE);
    cache_clear_all();
  }
}

/**
 * Implementation of hook_form_FORM_ID_alter().
 */
function elms_spaces_form_menu_edit_item_alter(&$form, &$form_state) {
  $form['menu']['token']['token_help']['help'] = array(
    '#value' => theme('token_help', array('global','node','user')),
  );
}

/**
 * Implementation of hook_translated_menu_link().
 * Modified version of menu_tokens function
 */
function elms_spaces_translated_menu_link_alter(&$item, $map) {
  $mlid = $item['mlid'];
  $menu_token_item = menu_token_get($mlid);
  // Check whether we should replace the path.
  if (isset($menu_token_item)) {
    // If item is generated by admin menu module, tokens should not be replaced and
    // indicator that tokens are used should be shown.
    if (_menu_token_menu_admin($item)) {
    }  
    else {
      // Replace with node tokens based on grabbing the right value
    $node = og_get_group_context();
    switch($menu_token_item['link_path']) {
    //fun made up token we're creating to give us the current path
    case '[q]':
      $menu_token_item['link_path'] = str_replace('[q]', $_GET['q'], $menu_token_item['link_path']);
    break;
    case 'node/add/version':
      //we're adding an version and the prepopulate is set
      if (arg(1) == 'add' && arg(2) == 'version') {
        $node = node_load(arg(3));
      }
      //see if we found a group / the node add
      if (!isset($node->nid)) {
        $node = node_load(arg(1));
      }
      //see if it's a course landing page we're on
      if ($node->type == 'course') {
        $menu_token_item['link_path'] .= '/'. $node->nid;
      }
      else {
        if(og_is_group_type($node->type)) {
          $menu_token_item['link_path'] .= '/'. $node->field_course_ref[0]['nid'];
        }
      }
    break;
    case 'node/[field_course_ref-nid]':
      if (arg(1) == 'add' && arg(2) == 'version') {
        $node = node_load(arg(3));
      }
      elseif (isset($node->nid)) {
        $node = node_load($node->field_course_ref[0]['nid']);
      }
        else {
      $node = node_load(arg(1));
      }
      //this node is type course and we're on that page
	  if (isset($node->type)) {
        if ($node->type == 'course') {
          $menu_token_item['link_path'] = 'node/[nid]';
          $item['title'] =  str_replace('[field_course_ref-title]','[title]',$item['title']);
        }
	  }
    break;
    case 'node/[nid]':
      if (arg(1) == 'add' && arg(2) == 'version' && $item['title'] != 'View [title]' && $item['title'] != '[title] ([workflow-current-state-name])') {
      $node = node_load($_GET['edit']['field_course_ref']['nid']['nid']);
      }
    break;
    case 'outline_designer/book/[book_id]':
      $menu_token_item['link_path'] = str_replace('[book_id]', $node->book_nid, $menu_token_item['link_path']);
    break;
    }
    if (isset($node->nid)) {
      $item['title'] =  token_replace($item['title'], 'node', $node);
      $item['link_path'] = token_replace($menu_token_item['link_path'], 'node', $node);
      $item['href'] = $item['link_path'];
    }
      // Override active trail if showing front page but translated link is not to front page.
      // NOTE: This relies on any parent of a tokenised menu item having "option" flag "alter" set,
      // which is most easily achieved by setting it to use token translation but not specifying a token.
      // Otherwise parent does not get processed through this function and because its untranslated child has
      // an href of <front>, the menu system thinks it is part of the active trail to the front page.
      if (drupal_is_front_page() && $item['href'] != drupal_get_normal_path(variable_get('site_frontpage', 'node'))) {
        $item['in_active_trail'] = FALSE;
      }

      // Check whether path is external.
      if (menu_path_is_external($item['link_path'])) {
        return;
      }

      // Load menu_item and check access.
      if ($menu_item = menu_get_item($item['link_path'])) {
        $item['access'] = $menu_item['access'];
        return;
      }

      $item['access'] = FALSE;
    }
  }
}

//create a course version off of default settings
function _elms_spaces_course_default($course) {
  global $user;
  //creating a blank node
  $group = new StdClass();
    $group->uid = $user->uid;
  //this title will change anyway on node insert
  $group->title = $course->title .' Master';
  $group->type = 'version';
  $group->status = 1;
  $group->log = 'Default settings used to create an initial course version';
  $group->revision = 1;
  $group->field_navigation[0]['value'] = 'left';
  $group->field_footer[0]['value'] = "&copy; Copyright 2011 The Pennsylvania State University and its licensors. All rights reserved.<br />
Penn State is an Equal Opportunity Employer.";
  $group->field_scoring_method[0]['value'] = 'points';
  //Set the course reference
  $group->field_course_ref[0]['nid'] = $course->nid;
  //set printing on by default
  $group->field_print_options[0]['value'] = 'both';
  //og settings
  $group->theme = 'chamfer';
  $group->og_theme = 'chamfer';
  $group->og_description = '';
  $group->og_private = 1;
  $group->field_lesson_count[0]['value'] = 15;
  //save node
  node_save($group);
  $space = spaces_load('og', $group->nid, TRUE);
  //catch some additional values that don't get set on a traditional insert
  if ($space) {
    $space->controllers->variable->set('spaces_preset_og', 'og_private');
    $space->controllers->variable->set('webaccess_secure_site', 1);
  }
  //set the multistep stuff so that it renders correctly after the fact
  _multistep_update_status($group->nid,'submitted',1);
  _multistep_update_status($group->nid,'submitted',2);
  _multistep_update_status($group->nid,'submitted',3);
  _multistep_update_status($group->nid,'submitted',4);
  _multistep_update_status($group->nid,'submitted',5);
  _multistep_update_status($group->nid,'submitted',6);
  //create the book root now that we have the group node finished
    _elms_spaces_create_root($group, 'default');
}
