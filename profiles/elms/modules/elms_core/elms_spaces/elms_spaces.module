<?php
// $Id: elms_spaces.module

/**
 * @file
 * Spaces specific helper functions to help organize space specific settings / pages into their own area
 */

/**
 * Implementation of hook_init()
 */
function elms_spaces_init() {
  //only add these settings to the node/%theme page
  if (arg(0) == 'theme') {
    drupal_add_js(drupal_get_path('module', 'elms_spaces') .'/elms_spaces.js');
  }
}
/**
 * Implementation of hook_menu()
 */
function elms_spaces_menu() {
  $items = array();
  $items['theme'] = array(
    'title' => 'Theme Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('_elms_spaces_theme_form'),
    'type' => MENU_NORMAL_ITEM,
  'access callback' => '_elms_spaces_theme_access',
    'access arguments' => array(),
    'file' => 'elms_spaces.theme.inc',
    'file path' => drupal_get_path('module','elms_spaces') .'/inc',
  );
  return $items;
}

//determine if someone can access the /theme page based on whether or not they have access to edit the space
//CHANGE access method to that of features as this check is overkill
function _elms_spaces_theme_access() {
  global $user;
  $node = og_get_group_context();
  if (!og_is_group_type($node->type) || !user_access('edit own course content')) {
    return 0;
  }

  return 1;
}

/*
 *rewrite of the function that rebuilds all node permissions in the system
 *helps speed things up by rebuilding things associated to the current group
 *need to rebuild all permissions of all nodes in the current group
 */
function _elms_spaces_node_access_rebuild_batch_operation($group, &$context) {
  if (empty($context['sandbox'])) {
    // Initiate multistep processing.
    $context['sandbox']['progress'] = 0;
    $context['sandbox']['current_node'] = 0;
    $context['sandbox']['max'] = db_result(db_query('SELECT COUNT(DISTINCT {node}.nid) FROM {node} JOIN {og_ancestry} ON {og_ancestry}.nid = {node}.nid WHERE group_nid=%d',$group->nid));
  db_query("DELETE FROM {node_access} WHERE nid=%d", $group->nid);
  //need to rebuild the group node's permission so we do that the first run
  $loaded_node = node_load($group->nid, NULL, TRUE);
    // To preserve database integrity, only aquire grants if the node
    // loads successfully.
    if (!empty($loaded_node)) {
      node_access_acquire_grants($loaded_node);
    }
  }

  // Process the next 50 nodes.
  $limit = 50;
  $result = db_query_range("SELECT {node}.nid FROM {node} JOIN {og_ancestry} ON {og_ancestry}.nid = {node}.nid WHERE {node}.nid > %d AND group_nid=%d ORDER BY {node}.nid ASC", $context['sandbox']['current_node'], $group->nid, 0, $limit);
  while ($row = db_fetch_array($result)) {
  //clear current records for the group
  db_query("DELETE FROM {node_access} WHERE nid=%d", $row['nid']);
  //load the node for grant rebuild
    $loaded_node = node_load($row['nid'], NULL, TRUE);
    // To preserve database integrity, only aquire grants if the node
    // loads successfully.
    if (!empty($loaded_node)) {
      node_access_acquire_grants($loaded_node);
    }
    $context['sandbox']['progress']++;
    $context['sandbox']['current_node'] = $row['nid'];
  }
  $context['message'] = 'Rebuilding Content Permissions: '. ($context['sandbox']['max'] - $context['sandbox']['progress']) .' pages remaining';
  // Multistep processing : report progress.
  if ($context['sandbox']['progress'] != $context['sandbox']['max']) {
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max'];
  }
  //last run
  if ($context['sandbox']['progress'] == $context['sandbox']['max']) {
  $context['message'] = t('Content permissions have been rebuilt.');
  og_node_access_needs_rebuild(FALSE);
    cache_clear_all();
  }
}
